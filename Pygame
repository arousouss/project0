import pygame
import random
import os

# --- INITIALISATION DE PYGAME ---
pygame.init()

# --- CONSTANTES ---
SCREEN_WIDTH = 1200
SCREEN_HEIGHT = 800
CARD_WIDTH = 70
CARD_HEIGHT = 100
FPS = 60

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREEN = (50, 150, 50)
LIGHT_BLUE = (173, 216, 230)

# --- FENÊTRE ---
SCREEN = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Pyramid Scramble")
CLOCK = pygame.time.Clock()

# --- CHEMINS DES ASSETS ---
ASSETS_DIR = "assets"
CARD_IMAGES_DIR = os.path.join(ASSETS_DIR, "cards")
CARD_BACK_IMAGE_PATH = os.path.join(ASSETS_DIR, "card_back.png")
BACKGROUND_IMAGE_PATH = os.path.join(ASSETS_DIR, "background.png")


# --- CHARGEMENT DES IMAGES ---
CARD_IMAGES = {}
CARD_BACK_IMAGE = None
BACKGROUND_IMAGE = None

try:
    # Charge le dos de carte
    CARD_BACK_IMAGE = pygame.image.load(CARD_BACK_IMAGE_PATH).convert_alpha()
    CARD_BACK_IMAGE = pygame.transform.scale(CARD_BACK_IMAGE, (CARD_WIDTH, CARD_HEIGHT))

    # Charge le fond (si existe)
    if os.path.exists(BACKGROUND_IMAGE_PATH):
        BACKGROUND_IMAGE = pygame.image.load(BACKGROUND_IMAGE_PATH).convert()
        BACKGROUND_IMAGE = pygame.transform.scale(BACKGROUND_IMAGE, (SCREEN_WIDTH, SCREEN_HEIGHT))

    # Charge toutes les images de cartes
    for filename in os.listdir(CARD_IMAGES_DIR):
        if filename.endswith(".png"):
            card_name = os.path.splitext(filename)[0] # Ex: AS_PIQUE
            img = pygame.image.load(os.path.join(CARD_IMAGES_DIR, filename)).convert_alpha()
            CARD_IMAGES[card_name] = pygame.transform.scale(img, (CARD_WIDTH, CARD_HEIGHT))
except Exception as e:
    print(f"Erreur de chargement d'image : {e}")
    print("Assurez-vous que le dossier 'assets/cards' existe et contient les images.")
    # On va gérer avec des couleurs si les images ne chargent pas
    CARD_BACK_IMAGE = pygame.Surface((CARD_WIDTH, CARD_HEIGHT))
    CARD_BACK_IMAGE.fill(BLACK) # Noir si pas d'image
    BACKGROUND_IMAGE = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
    BACKGROUND_IMAGE.fill(GREEN) # Vert si pas de fond


# --- CLASSES DU JEU ---

class Card:
    RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
    SUITS = ['PIQUE', 'COEUR', 'CARREAU', 'TREFLE'] # Pour correspondre aux noms de fichiers

    def __init__(self, rank, suit):
        self.rank = rank
        self.suit = suit
        self.face_up = True
        self.image = self._get_image()
        self.rect = self.image.get_rect()

    def _get_image(self):
        # Cherche l'image correspondante
        img_name = f"{self.rank}_{self.suit}"
        if img_name in CARD_IMAGES:
            return CARD_IMAGES[img_name]
        else:
            # Fallback si l'image n'est pas trouvée
            temp_surface = pygame.Surface((CARD_WIDTH, CARD_HEIGHT))
            temp_surface.fill((200, 200, 200)) # Gris
            font = pygame.font.Font(None, 24)
            text = font.render(f"{self.rank}-{self.suit[0]}", True, BLACK)
            text_rect = text.get_rect(center=(CARD_WIDTH // 2, CARD_HEIGHT // 2))
            temp_surface.blit(text, text_rect)
            return temp_surface

    def draw(self, surface, x, y):
        self.rect.topleft = (x, y)
        if self.face_up:
            surface.blit(self.image, self.rect)
        else:
            surface.blit(CARD_BACK_IMAGE, self.rect)

    def __repr__(self):
        return f"{self.rank} de {self.suit}"

class Deck:
    def __init__(self):
        self.cards = []
        for suit in Card.SUITS:
            for rank in Card.RANKS:
                self.cards.append(Card(rank, suit))
        self.shuffle()

    def shuffle(self):
        random.shuffle(self.cards)

    def deal(self, num_cards):
        dealt_cards = []
        for _ in range(num_cards):
            if self.cards:
                dealt_cards.append(self.cards.pop())
        return dealt_cards
    
    def add_card(self, card):
        self.cards.append(card)

class Hand:
    def __init__(self, player_name="Joueur"):
        self.player_name = player_name
        self.cards = []

    def add_card(self, card):
        self.cards.append(card)
        self.sort_hand() # Garder la main triée peut être utile

    def remove_card(self, card_to_remove):
        self.cards = [c for c in self.cards if c != card_to_remove]
        self.sort_hand()

    def sort_hand(self):
        # Trie par couleur puis par rang (ex: Pique A, Pique 2, ..., Coeur A, ...)
        rank_values = {rank: i for i, rank in enumerate(Card.RANKS)}
        suit_values = {suit: i for i, suit in enumerate(Card.SUITS)}
        self.cards.sort(key=lambda card: (suit_values[card.suit], rank_values[card.rank]))

    def draw(self, surface, x, y):
        # Affiche les cartes du joueur
        for i, card in enumerate(self.cards):
            card.draw(surface, x + i * (CARD_WIDTH + 10), y)

class Pyramid:
    def __init__(self, size=3):
        self.cards = [None] * size # Une liste pour les 3 cartes de la pyramide
        self.rects = [] # Pour stocker les rects pour les clics

    def set_cards(self, new_cards):
        self.cards = new_cards

    def draw(self, surface, x, y):
        self.rects = []
        for i, card in enumerate(self.cards):
            card_x = x + i * (CARD_WIDTH + 20)
            card.draw(surface, card_x, y)
            self.rects.append(card.rect) # Sauvegarde la position pour les clics

    def replace_card(self, index, new_card):
        if 0 <= index < len(self.cards):
            old_card = self.cards[index]
            self.cards[index] = new_card
            return old_card # Retourne l'ancienne carte pour la défausse
        return None

    def get_card_at_pos(self, pos):
        for i, rect in enumerate(self.rects):
            if rect.collidepoint(pos):
                return self.cards[i], i
        return None, -1


class Game:
    def __init__(self):
        self.deck = Deck()
        self.discard_pile = []
        self.player_hand = Hand("Joueur 1")
        self.pyramid = Pyramid(size=3)
        self.selected_card = None # Carte que le joueur a cliquée dans sa main
        self.message = ""

        self.setup_game()

    def setup_game(self):
        self.player_hand.cards = self.deck.deal(5)
        self.pyramid.set_cards(self.deck.deal(3))
        self.message = "Choisissez une carte de votre main, puis une carte de la pyramide."

    def is_valid_move(self, hand_card, pyramid_card):
        # Règle: même couleur OU même rang
        return hand_card.suit == pyramid_card.suit or hand_card.rank == pyramid_card.rank

    def handle_click(self, pos):
        # 1. Clic sur la main du joueur
        for card_in_hand in self.player_hand.cards:
            if card_in_hand.rect.collidepoint(pos):
                self.selected_card = card_in_hand
                self.message = f"Carte sélectionnée : {self.selected_card}. Maintenant, cliquez sur une carte de la pyramide."
                return

        # 2. Clic sur la pyramide (si une carte de main est sélectionnée)
        if self.selected_card:
            pyramid_card, pyramid_index = self.pyramid.get_card_at_pos(pos)
            if pyramid_card:
                if self.is_valid_move(self.selected_card, pyramid_card):
                    # Effectue le coup
                    old_pyramid_card = self.pyramid.replace_card(pyramid_index, self.selected_card)
                    self.player_hand.remove_card(self.selected_card)
                    self.discard_pile.append(old_pyramid_card)
                    self.message = "Coup valide ! Passez au tour suivant."
                    self.selected_card = None
                    self.check_game_over()
                else:
                    self.message = "Coup invalide. La carte doit correspondre en couleur ou en rang."
            else:
                self.message = "Cliquez sur une carte de la pyramide pour jouer."
            return

        # 3. Clic sur la pioche (si aucune carte sélectionnée ou coup invalide)
        # Pour l'instant, pas de pioche automatique, le joueur clique pour passer.
        # Implémentation future: Bouton "Passer / Piocher"


    def check_game_over(self):
        if not self.player_hand.cards:
            self.message = "Félicitations ! Vous avez vidé votre main ! Vous avez gagné !"
            # Potentiellement un écran de victoire ou un bouton pour rejouer
            
    def draw(self, surface):
        if BACKGROUND_IMAGE:
            surface.blit(BACKGROUND_IMAGE, (0, 0))
        else:
            surface.fill(GREEN) # Fond vert uni

        # Dessine la main du joueur
        font = pygame.font.Font(None, 30)
        text = font.render("Votre Main:", True, BLACK)
        surface.blit(text, (50, SCREEN_HEIGHT - CARD_HEIGHT - 40))
        self.player_hand.draw(surface, 50, SCREEN_HEIGHT - CARD_HEIGHT - 20)

        # Dessine la pyramide
        text = font.render("Pyramide:", True, BLACK)
        surface.blit(text, (50, 50))
        self.pyramid.draw(surface, 50, 80)

        # Affiche les messages
        message_font = pygame.font.Font(None, 36)
        message_text = message_font.render(self.message, True, BLACK)
        surface.blit(message_text, (SCREEN_WIDTH // 2 - message_text.get_width() // 2, SCREEN_HEIGHT // 2))

        # Met en évidence la carte sélectionnée
        if self.selected_card:
            pygame.draw.rect(surface, LIGHT_BLUE, self.selected_card.rect, 3) # Bordure bleue

# --- BOUCLE DE JEU ---
def main():
    game = Game()
    running = True

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1: # Clic gauche
                    game.handle_click(event.pos)

        SCREEN.fill(GREEN) # Remplir l'écran avant de redessiner
        game.draw(SCREEN)
        
        pygame.display.flip() # Met à jour l'écran
        CLOCK.tick(FPS)

    pygame.quit()

if __name__ == "__main__":
    main()
