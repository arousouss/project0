import streamlit as st
import random
from dataclasses import dataclass
from typing import List, Optional, Tuple

# --- CONFIGURATION DE LA PAGE ---
st.set_page_config(
    page_title="Pyramid Scramble",
    page_icon="ğŸ´",
    layout="wide"
)

# --- CLASSES DU JEU ---

@dataclass
class Card:
    rank: str
    suit: str
    face_up: bool = True
    
    RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
    SUITS = {'PIQUE': 'â™ ï¸', 'COEUR': 'â™¥ï¸', 'CARREAU': 'â™¦ï¸', 'TREFLE': 'â™£ï¸'}
    SUIT_COLORS = {'PIQUE': 'black', 'COEUR': 'red', 'CARREAU': 'red', 'TREFLE': 'black'}
    
    def __repr__(self):
        return f"{self.rank}{self.SUITS[self.suit]}"
    
    def get_display(self):
        return f"{self.rank} {self.SUITS[self.suit]}"
    
    def get_color(self):
        return self.SUIT_COLORS[self.suit]

class Deck:
    def __init__(self):
        self.cards = []
        for suit in Card.SUITS.keys():
            for rank in Card.RANKS:
                self.cards.append(Card(rank, suit))
        self.shuffle()
    
    def shuffle(self):
        random.shuffle(self.cards)
    
    def deal(self, num_cards: int) -> List[Card]:
        dealt_cards = []
        for _ in range(num_cards):
            if self.cards:
                dealt_cards.append(self.cards.pop())
        return dealt_cards

class Hand:
    def __init__(self, player_name: str = "Joueur"):
        self.player_name = player_name
        self.cards: List[Card] = []
    
    def add_card(self, card: Card):
        self.cards.append(card)
        self.sort_hand()
    
    def remove_card(self, card: Card):
        self.cards = [c for c in self.cards if c != card]
        self.sort_hand()
    
    def sort_hand(self):
        rank_values = {rank: i for i, rank in enumerate(Card.RANKS)}
        suit_values = {suit: i for i, suit in enumerate(Card.SUITS.keys())}
        self.cards.sort(key=lambda card: (suit_values[card.suit], rank_values[card.rank]))

class Pyramid:
    def __init__(self, size: int = 3):
        self.cards: List[Optional[Card]] = [None] * size
    
    def set_cards(self, new_cards: List[Card]):
        self.cards = new_cards
    
    def replace_card(self, index: int, new_card: Card) -> Optional[Card]:
        if 0 <= index < len(self.cards):
            old_card = self.cards[index]
            self.cards[index] = new_card
            return old_card
        return None

# --- INITIALISATION DE L'Ã‰TAT DU JEU ---

def init_game():
    """Initialise un nouveau jeu"""
    deck = Deck()
    st.session_state.deck = deck
    st.session_state.discard_pile = []
    st.session_state.player_hand = Hand("Joueur 1")
    st.session_state.pyramid = Pyramid(size=3)
    st.session_state.selected_card_index = None
    st.session_state.message = "Choisissez une carte de votre main, puis une carte de la pyramide."
    st.session_state.game_over = False
    
    # Distribution initiale
    st.session_state.player_hand.cards = deck.deal(5)
    st.session_state.pyramid.set_cards(deck.deal(3))

# Initialisation au premier lancement
if 'deck' not in st.session_state:
    init_game()

# --- FONCTIONS DU JEU ---

def is_valid_move(hand_card: Card, pyramid_card: Card) -> bool:
    """VÃ©rifie si un coup est valide (mÃªme couleur OU mÃªme rang)"""
    return hand_card.suit == pyramid_card.suit or hand_card.rank == pyramid_card.rank

def play_card(hand_card_index: int, pyramid_index: int):
    """Joue une carte de la main sur la pyramide"""
    hand_card = st.session_state.player_hand.cards[hand_card_index]
    pyramid_card = st.session_state.pyramid.cards[pyramid_index]
    
    if is_valid_move(hand_card, pyramid_card):
        # Effectue le coup
        old_pyramid_card = st.session_state.pyramid.replace_card(pyramid_index, hand_card)
        st.session_state.player_hand.remove_card(hand_card)
        st.session_state.discard_pile.append(old_pyramid_card)
        st.session_state.message = "âœ… Coup valide ! Continuez Ã  jouer."
        st.session_state.selected_card_index = None
        
        # VÃ©rifie la victoire
        if not st.session_state.player_hand.cards:
            st.session_state.message = "ğŸ‰ FÃ©licitations ! Vous avez vidÃ© votre main ! Vous avez gagnÃ© !"
            st.session_state.game_over = True
    else:
        st.session_state.message = "âŒ Coup invalide. La carte doit correspondre en couleur ou en rang."
        st.session_state.selected_card_index = None

# --- INTERFACE STREAMLIT ---

st.title("ğŸ´ Pyramid Scramble")
st.markdown("---")

# CSS personnalisÃ© pour les cartes
st.markdown("""
<style>
.card {
    border: 2px solid #333;
    border-radius: 8px;
    padding: 15px;
    text-align: center;
    font-size: 24px;
    font-weight: bold;
    background: white;
    box-shadow: 2px 2px 8px rgba(0,0,0,0.2);
    min-width: 80px;
    min-height: 110px;
    display: flex;
    align-items: center;
    justify-content: center;
}
.card-selected {
    border: 4px solid #4CAF50;
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
}
.card-red {
    color: red;
}
.card-black {
    color: black;
}
</style>
""", unsafe_allow_html=True)

# Messages et statut
col_msg, col_btn = st.columns([3, 1])
with col_msg:
    if st.session_state.game_over:
        st.success(st.session_state.message)
    else:
        st.info(st.session_state.message)

with col_btn:
    if st.button("ğŸ”„ Nouvelle Partie", use_container_width=True):
        init_game()
        st.rerun()

st.markdown("---")

# --- PYRAMIDE ---
st.subheader("ğŸ”º Pyramide")
pyramid_cols = st.columns(3)

for i, card in enumerate(st.session_state.pyramid.cards):
    with pyramid_cols[i]:
        if card:
            color = "red" if card.get_color() == "red" else "black"
            st.markdown(f"<div class='card card-{color}'>{card.get_display()}</div>", unsafe_allow_html=True)
            
            if st.session_state.selected_card_index is not None and not st.session_state.game_over:
                if st.button(f"Jouer ici", key=f"pyramid_{i}", use_container_width=True):
                    play_card(st.session_state.selected_card_index, i)
                    st.rerun()

st.markdown("---")

# --- MAIN DU JOUEUR ---
st.subheader("ğŸƒ Votre Main")

if st.session_state.player_hand.cards:
    hand_cols = st.columns(len(st.session_state.player_hand.cards))
    
    for i, card in enumerate(st.session_state.player_hand.cards):
        with hand_cols[i]:
            color = "red" if card.get_color() == "red" else "black"
            selected_class = "card-selected" if st.session_state.selected_card_index == i else ""
            st.markdown(f"<div class='card card-{color} {selected_class}'>{card.get_display()}</div>", unsafe_allow_html=True)
            
            if not st.session_state.game_over:
                if st.button(f"SÃ©lectionner", key=f"hand_{i}", use_container_width=True):
                    st.session_state.selected_card_index = i
                    st.session_state.message = f"Carte sÃ©lectionnÃ©e : {card}. Cliquez sur une carte de la pyramide."
                    st.rerun()
else:
    st.write("Votre main est vide !")

# --- STATISTIQUES ---
st.markdown("---")
stat_cols = st.columns(3)
with stat_cols[0]:
    st.metric("Cartes en main", len(st.session_state.player_hand.cards))
with stat_cols[1]:
    st.metric("Cartes dans le deck", len(st.session_state.deck.cards))
with stat_cols[2]:
    st.metric("Cartes dÃ©faussÃ©es", len(st.session_state.discard_pile))

# --- RÃˆGLES ---
with st.expander("ğŸ“– RÃ¨gles du jeu"):
    st.markdown("""
    **Objectif :** Vider votre main en jouant toutes vos cartes sur la pyramide.
    
    **Comment jouer :**
    1. SÃ©lectionnez une carte de votre main
    2. Cliquez sur une carte de la pyramide pour l'y placer
    3. Votre carte remplacera la carte de la pyramide si elle a la **mÃªme couleur** OU le **mÃªme rang**
    4. La carte remplacÃ©e va dans la dÃ©fausse
    5. Continuez jusqu'Ã  vider votre main !
    
    **Exemple :**
    - Vous pouvez jouer un 7â™ ï¸ sur un 7â™¥ï¸ (mÃªme rang)
    - Vous pouvez jouer un Kâ™ ï¸ sur un Aâ™ ï¸ (mÃªme couleur)
    """)
